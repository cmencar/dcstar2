# -*- coding: utf-8 -*-
# FINAL VERSION

import random
import time
from deap import creator, base, tools, algorithms
from genetic_algorithm.genetic_evolution import GeneticEvolution
from cut_sequences.selected_dimensional_sequence_numeric import SelectedDimensionalSequenceNumeric
from cut_sequences.dimensional_sequence_binary import DimensionalSequenceBinary
# from matplotlib import pyplot as plt
# import numpy as np


# Class for utilization of genetic guide using DEAP
class DeapGeneticGuideSequenceProblem(GeneticEvolution):

    # Definition constructor class
    # @individual_size: number of attributes for each individual
    # @mutation_rate: percentage of mutation
    # @mating_rate: mating ratio
    # @selected_individuals: number of individuals selected in the phase of selection of the best individuals
    # (selection by tournament)
    # @cuts_sequence: sequence of cuts T_d
    # @points_list: list of prototypes
    # @elements_per_dimension: number of elements per dimension of given cuts_sequence for convertion from chromosome
    # to sequence
    # @min_cut: m_d cut that will go into S_d
    # @max_cut: M_d cut that will go into S_d
    def __init__(self, individual_size, mutation_rate, cuts_sequence, points_list, elements_per_dimension, min_cut,
                 max_cut):

        # save cuts_sequence, points_list, individual_size and element_per_dimension, needed for convertion from
        # chromosome to sequence
        self.T_d = cuts_sequence
        self.points_list = points_list
        self.individual_size = individual_size
        self.elements_per_dimension = elements_per_dimension
        # save m_d and M_d limits to generate S_d sequence
        self.m_d = min_cut
        self.M_d = max_cut

        # initialize the seed for random numbers
        random.seed()

        # define applicability of mating and mutation of individuals
        self.cxpb = 0.5
        self.mutpb = 0.2

        # create object defining max fitness value
        creator.create("FitnessMax", base.Fitness, weights=(1.0,))

        # create object defining individual
        creator.create("Individual", list, fitness=creator.FitnessMax)

        # define toolbox for needed methods
        self.toolbox = base.Toolbox()

        # define individual, which will be generated by a given "generate_fun" function
        self.toolbox.register("individual", self.generate, creator.Individual, individual_size)

        # define data structure "population" containing all individuals
        self.toolbox.register("population", tools.initRepeat, list, self.toolbox.individual)

        # define mating method between individuals
        self.toolbox.register("mate", tools.cxOnePoint)

        # define mutation method of individuals' son
        self.toolbox.register("mutate", tools.mutFlipBit, indpb=mutation_rate)

        # define selection method
        if self.individual_size * 0.2 < 10:
            self.toolbox.register("select", tools.selTournament, tournsize=1)  # for really small populations
        else:
            self.toolbox.register("select", tools.selTournament, tournsize=int(individual_size * 0.2))  # 10% of pop

        # define evaluation method
        self.toolbox.register("evaluate", self.evaluate)

    # Function that calculates and individual's fitness
    # @individual: object that contains the genome
    def evaluate(self, individual):
        return (1 - self.used_cuts_ratio(individual)) * pow(self.pureness(individual), 5)

    # Method that calculates used cuts ratio of a given individual
    # @individual: individual
    def used_cuts_ratio(self, individual):
        # initialize true and total genes counter
        true_genes = 0
        total_genes = 0

        # count true genes
        true_genes += individual.count(True)

        # count total genes
        total_genes += len(individual)

        # return ratio of true genes and total genes
        return true_genes / total_genes

    # Method that calculates the pureness of a given individual
    # @individual: individual
    def pureness(self, individual):
        # initialize selected cuts and binary cuts sequences
        S_d = SelectedDimensionalSequenceNumeric()
        S_d_b = DimensionalSequenceBinary()

        # convert individual into sequence
        converted_individual = self.from_ind_to_sequence(individual, self.elements_per_dimension)

        # create binary cuts sequence
        S_d_b.from_binary(converted_individual)
        # generate selected cuts sequence from reference T_d and binary cuts sequence
        S_d.from_binary(self.T_d, S_d_b)

        # create set of hyperboxes
        hyperboxes = S_d.generate_hyperboxes_set(self.points_list, self.m_d, self.M_d)

        # return ratio between number of pure hyperboxes and total number of hyperboxes
        return hyperboxes.get_pure_hyperboxes_number() / hyperboxes.get_hyperboxes_number()

    # Function that generates an individual with the same number of cuts as the cuts sequence
    # @individual_class: class of the individual to create
    # @individual_dim: number of genes of the individual
    def generate(self, individual_class, individual_dim):
        # definition of individual's genome
        chromosome = list()

        # initializing the genome with all genes to False
        for gene in range(individual_dim):
            chromosome.append(False)

        # return the individual with the created genome
        return individual_class(chromosome)

    # Method generating the best individual possible by the genetic algorithm
    # @population_size: size of population to generate
    # @generations: number of generations to create
    # @selected_best: number of best individuals to generate
    def evolve(self, population_size, generations, dataset):

        start_time = time.time()

        # create a population of "population_size" individuals
        population = self.toolbox.population(n=population_size)

        fit_behave = list(tuple())  # TODO - valutazione fitness, da togliere
        fit_behave.append((0, 0, 0))

        # initialize best individual
        bestfit = 0
        oldfit = 0.8
        bestind = None

        # create first "hall of fame" of elites with initial fitness
        elites_fits = []
        if self.individual_size < 10:
            elites = self.toolbox.population(n=2)
        else:
            elites = self.toolbox.population(n=int(self.individual_size * 0.1))
        for i in range(len(elites)):
            elites_fits.append(0)

        # initialize epoch and convergence counters
        epoch = 0
        convergence = 0
        # while there are generations to be computed and there is no convergence in max fitness values over generations
        while epoch < generations - 1 and convergence < 10:

            # generate offsprings of current population
            offsprings = algorithms.varAnd(population, self.toolbox, self.cxpb, self.mutpb)

            # define mapping of calculated fitnesses to corresponding individuals
            fitnesses = list(map(self.toolbox.evaluate, offsprings))

            # TODO - valutazione fitness, da togliere
            '''
            eval_fitness = fitnesses.copy()
            current_max_fit = 0
            current_min_fit = 1
            temp_avg = 0
            for i in range(len(eval_fitness)):
                if eval_fitness[i] > current_max_fit:
                    current_max_fit = eval_fitness[i]
                if eval_fitness[i] < current_min_fit:
                    current_min_fit = eval_fitness[i]
                temp_avg += eval_fitness[i]
                current_avg_fit = temp_avg / population_size
            fit_behave.append((current_min_fit, current_avg_fit, current_max_fit))
            '''

            # map each fitness value to the corresponding offspring
            for ind, fit in zip(offsprings, fitnesses):
                # if an individual had better fitness than the best found so far
                if fit > bestfit:
                    # save the best individual
                    bestfit = float(fit)
                    bestind = ind.copy()
                ind.fitness.setValues((fit, fit, 1))

            # stop nr°2 (convergence of max fitness)
            if bestfit >= oldfit:
                if bestfit == oldfit:
                    convergence += 1
                else:
                    oldfit = float(bestfit)
                    convergence = 0
            else:
                convergence = 0

            # update the elites' list
            clones = offsprings.copy()
            clones.sort(key=lambda offspring: offspring.fitness.values, reverse=True)
            fitnesses.sort(reverse=True)
            for i in range(len(elites_fits)):
                if fitnesses[i] > elites_fits[elites_fits.index(min(elites_fits))]:
                    elites[elites_fits.index(min(elites_fits))] = creator.Individual(clones[i].copy())
                    elites_fits[elites_fits.index(min(elites_fits))] = float(fitnesses[i])

            # select "n - k" offsprings that will be the next population
            # @n: population size
            # @k: number of elite individuals
            population = self.toolbox.select(offsprings, k=population_size - len(elites))
            # insert k elites into current population into random positions
            for elite in elites:
                population.insert(random.randint(0, len(population)), elite)

            # stop nr°1 (number of generations)
            epoch += 1

        # TODO - grafico valutazione fitness, da togliere
        '''
        min_ = list()
        avg_ = list()
        max_ = list()
        for fits in fit_behave:
            min_.append(fits[0])
            avg_.append(fits[1])
            max_.append(fits[2])
        x = np.linspace(0, len(fit_behave), len(fit_behave))
        plt.plot(x, min_, marker='.', color='red')
        plt.plot(x, avg_, marker='.', color='green')
        plt.plot(x, max_, marker='.', color='blue')
        plt.grid(True)
        plt.savefig(dataset + ".svg", transparent=True)
        plt.close()
        '''

        print("Best fitness: ", bestfit)
        print("Total cuts in individual: ", self.individual_size)
        print("Active cuts in best individual: ", bestind.count(True))
        print("Elapsed time: ", time.time() - start_time)

        # convert individual into sequence
        best_individual = self.from_ind_to_sequence(bestind, self.elements_per_dimension)

        # return the converted best individual
        return best_individual
        # return bestind.count(True), self.individual_size

    # Method converting individual from list to list of lists
    # @individual: individual
    # @genes_per_dimension: numbers of genes per dimension
    def from_ind_to_sequence(self, individual, genes_per_dimension):
        # create support lists
        sequence = list()
        dimension = list()

        # initialize index and offset variables
        offset = 0
        i = 0
        # for each dimension
        for num_elem in genes_per_dimension:
            # clear the "dimension" support list
            dimension.clear()
            # increment the offset that limits how many genes are copied into given dimension
            offset = offset + num_elem

            # while index doesn't reach the max elements in given dimension
            while i < offset:
                # append into given dimension the gene with given index from individual
                dimension.append(individual[i])
                # increment index
                i += 1
            # append a copy of the newly created dimension into sequence
            sequence.append(dimension.copy())
        return sequence
