# -*- coding: utf-8 -*-

from deap import creator, base, tools, algorithms
from genetic_algorithm.genetic_evolution import GeneticEvolution
from cut_sequences.selected_cuts_sequence import SelectedCutsSequence
from cut_sequences.dimensional_sequence_binary import DimensionalSequenceBinary


# Class for utilization of genetic guide using DEAP
class DeapGeneticGuide(GeneticEvolution):

    # Definition constructor class
    # @evaluate_fun: passed function that evaluates the individual
    # @generate_fun: passed function that generates the individual
    # @individual_size: number of attributes for each individual
    # @mutation_rate: percentage of mutation
    # @mating_rate: mating ratio
    # @selected_individuals: number of individuals selected in the phase of selection of the best individuals
    # (selection by tournament)
    # @cuts_sequence: sequence of cuts T_d
    # @points_list: list of prototypes
    # @elements_per_dimension: number of elements per dimension of given cuts_sequence for convertion from list
    # to sequence
    def __init__(self, evaluate_fun, generate_fun, individual_size,
                 mutation_rate, mating_rate, selected_individuals, cuts_sequence, points_list, elements_per_dimension):

        # define mutation rate of individual
        self.mutation_rate = mutation_rate

        # define mating rate of individual
        self.mating_rate = mating_rate

        # create object defining max fitness value
        creator.create("FitnessMax", base.Fitness, weights=(1.0,))

        # create object defining individual
        creator.create("Individual", list, fitness=creator.FitnessMax)

        # define toolbox for needed methods
        self.toolbox = base.Toolbox()

        # define individual, which will be generated by a given "generate_fun" function
        self.toolbox.register("individual", generate_fun, creator.Individual, individual_size)

        # define data structure "population" containing all individuals
        self.toolbox.register("population", tools.initRepeat, list, self.toolbox.individual)

        # define mating method between individuals using uniform partially matched crossover
        self.toolbox.register("mate", tools.cxUniformPartialyMatched, indpb=0)

        # define mutation method of individuals' son shuffling genes with "mutation_rate" percentage
        self.toolbox.register("mutate", tools.mutShuffleIndexes, indpb=mutation_rate)

        # define selection method using selection for tournament between "selected_individuals" individuals
        self.toolbox.register("select", tools.selTournament, tournsize=selected_individuals)

        # define evaluation method with given "evaluate_fun" function
        self.toolbox.register("evaluate", evaluate_fun)

        # save cuts_sequence, points_list, individual_size and element_per_dimension, needed for convertion from
        # monodimensional list to sequence in "pureness" function
        self.T_d = cuts_sequence
        self.points_list = points_list
        self.individual_size = individual_size
        self.elements_per_dimension = elements_per_dimension

    # Individual evaluation method
    def evaluate(self, individual):
        pass

    # Individual generator method
    def generate(self):
        pass

    # Method generating best individuals by the genetic algorithm
    # @population_size: number of individuals to generate
    # @generations: number of generations to create
    # @selected_best: list of best individuals generated
    def evolve(self, population_size, generations, selected_best):

        # create a population of "population_size" individuals using the given "generate_fun" function
        population = self.toolbox.population(n=population_size)

        # for each generation
        for epoch in range(generations):

            # offsprings are generated using the varAnd algorithm, in which are passed the population, mating rate and
            # mutation rate
            # in this are used the previous defined methods in the toolbox, such as mutation, crossover, evaluation and
            # selection
            offsprings = algorithms.varAnd(population, self.toolbox, self.mating_rate, self.mutation_rate)

            # create a list of fitness values of the offsprings
            son_fitness = list()
            for son in offsprings:
                son_fitness.append(self.fitness(son, self.T_d, self.points_list))

            # map each fitness value to the corresponding offspring
            for fit, ind in zip(son_fitness, offsprings):
                ind.fitness.value = fit

            # select a number of offsprings equal to the number of individuals in the population
            # the selection is defined on a "selected_individual" number of offsprings
            population = self.toolbox.select(offsprings, k=len(population))

        # select the "selected_best" number of best individuals with the highest fitness value
        best_individuals = tools.selBest(population, selected_best, fit_attr="fitness.value")

        # initialize list of sequences (multidimensional individuals) and other support lists
        converted_best_individuals = list()

        # for each individual in the selected best
        for individual in best_individuals:
            # convert individual from monodimensional list to "binary cuts sequence"
            converted_best_individuals.append(self.from_monodim_ind_to_multidim_ind(individual,
                                                                                    self.elements_per_dimension))
        # create selected cuts sequence and binary dimensional sequence objects
        S_d = SelectedCutsSequence()
        S_d_b = DimensionalSequenceBinary()

        # define pure individuals list
        best_pure_individuals = list()

        # for each individual in the best individuals generated
        for individual in converted_best_individuals:
            # generate binary sequence from the individual
            S_d_b.from_binary(individual)

            # generate selected cuts sequence from cuts sequence and newly generated binary sequence
            S_d.from_binary(self.T_d, S_d_b)

            # create set of hyperboxes from selected cuts sequence, points list, m_d and M_d
            hyperboxes = S_d.generate_hyperboxes_set(self.points_list, 0, 1)

            # if all of the hyperboxes generated are pure
            if hyperboxes.get_impure_hyperboxes_number() == 0:
                # append the evaluated individual into the list of pure individuals
                best_pure_individuals.append(individual.copy())

        # if is found a pure individual at least
        if len(best_pure_individuals) != 0:
            # create a list of numbers of "active cuts" for each individual
            individuals_active_cuts = list()

            # for each pure individual
            for individual in best_pure_individuals:
                # initialize counter of active cuts
                num_active_cuts = 0

                # for each dimension of the evaluated individual
                for dimension in individual:
                    # increment the counter of active cuts
                    num_active_cuts += dimension.count(True)

                # append into the list of active cuts the counter of evaluated individual
                individuals_active_cuts.append(num_active_cuts)

            # initialize "best of the best" individual with his number of active cuts
            best_of_the_best = best_pure_individuals[0].copy()
            best_num_active_cuts = individuals_active_cuts[0]

            # for each pure individual
            for individual_index in range(len(best_pure_individuals)):
                # if the number of evaluated individual's active cuts is less than the "best of the best"
                if individuals_active_cuts[individual_index] < best_num_active_cuts:
                    # the evaluated individual is the new "best of the best" with his minor number of active cuts
                    best_of_the_best.clear()
                    best_of_the_best = best_pure_individuals[individual_index].copy()

            # return the "best of the best"
            return best_of_the_best
        else:
            # return the "worst case scenario"
            return self.worst_case_scenario(self.elements_per_dimension)

    # Method defining the fitness value of an individual
    # @individual: individual's genome
    # @T_d: reference cuts sequence
    # @points_list: list of prototypes
    def fitness(self, individual, T_d, points_list):
        # return the calculated fitness value
        return (1 - self.toolbox.evaluate(individual)) * pow(self.pureness(individual, T_d, points_list,
                                                                           self.elements_per_dimension), 5)

    # Method that calculates the pureness of a given individual's genome
    # @individual: individual's genome
    # @T_d: reference cuts sequence
    # @points_list: list of prototypes
    # @elements_per_dimension: number of elements in each dimension of reference T_d
    # @m_d: minimum cut for each dimension
    # @M_d: maximum cut for each dimension
    def pureness(self, individual, T_d, points_list, elements_per_dimension, m_d=0, M_d=1):
        # initializing selected cuts and binary cuts sequences
        S_d = SelectedCutsSequence()
        S_d_b = DimensionalSequenceBinary()

        # convert individual from monodimensional list to "multidimensional cut sequence"
        converted_individual = self.from_monodim_ind_to_multidim_ind(individual, elements_per_dimension)

        # create binary cuts sequence
        S_d_b.from_binary(converted_individual)
        # generate selected cuts sequence from reference T_d and binary cuts sequence
        S_d.from_binary(T_d, S_d_b)

        # create set of hyperboxes
        hyperboxes = S_d.generate_hyperboxes_set(points_list, m_d, M_d)

        # return ratio between number of pure hyperboxes and total number of hyperboxes
        return hyperboxes.get_pure_hyperboxes_number() / hyperboxes.get_hyperboxes_number()

    # Method converting individual's genome from list to "multidimensional cuts sequence"
    # @individual: individual's genome
    # @genes_per_dimension: numbers of genes per dimension
    def from_monodim_ind_to_multidim_ind(self, individual, genes_per_dimension):
        sequence = list()
        dimension = list()
        offset = 0
        i = 0
        for num_elem in genes_per_dimension:
            dimension.clear()
            offset = offset + num_elem
            while i < offset:
                dimension.append(individual[i])
                i += 1
            sequence.append(dimension.copy())
        return sequence

    # Method for the worst case scenario, generates a sequence with all the possible cuts active
    # @elements_per_dimension: number of cuts per dimension in reference T_d
    def worst_case_scenario(self, elements_per_dimension):
        # create support lists
        sequence = list()
        dimension = list()

        #for each dimension
        for dim in range(len(elements_per_dimension)):
            # clear the "dimension" support list
            dimension.clear()

            # for each element in given dimension
            for num in range(elements_per_dimension[dim]):
                # append True into dimension
                dimension.append(True)
            # append a copy of the newly created dimension into sequence
            sequence.append(dimension.copy())
        return sequence
