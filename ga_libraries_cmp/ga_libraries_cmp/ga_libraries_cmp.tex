\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\hypersetup{
	colorlinks=true,
	linkcolor=blue,
	filecolor=magenta,      
	urlcolor=cyan,
}

\urlstyle{same}

\DeclareUnicodeCharacter{FB01}{fi} 
\DeclareUnicodeCharacter{FB02}{fl}

\title{Genetics Algorithm in python}
\author{Jamiro Screti   Mat: 656848 }
\date{September 2019}

\begin{document}
	
	\maketitle
	
	\tableofcontents
	\section{Introduction}
	\subsection{What is a genetic algorithm?}
	A genetic algorithm( \textbf{GA}) is a meta-heuristic inspired by Charles Darwin's theory of natural evolution (selection), that belongs into a larger class of evolutionary algorithms (\textbf{EA}). \newline
	The most common usage of GAs is to generate solutions to \textit{optimization} and \textit{search problems}, by relying on biologically-inspired operators, which are:
	\begin{itemize}
		\item \textbf{Mutation}: Used to maintain genetic diversity inside the population, altering one or more genes from its initial state, which may result in entirely different solutions from the previous ones;
		\item \textbf{Cross-over} : also called \textit{recombination}, is used to combine the genetic information of two-parent when generating the new offspring. The new offspring can be generated by cloning an existing solution, but before being added into the new population, cloned solution are typically mutated;
		\item \textbf{Selection}: A stage of a generic GA in which the individual genomes are being chosen from the population, using a specifically created function called \textit{fitness }, that determines which genomes can be chosen for later breeding (using the crossover operator).
	\end{itemize}
	\subsection{How does a basic Genetic algorithm works}
	The most basic functioning of a GA is the following:
	\begin{enumerate}
		\item Individual in population compete for resources and mate
		\item Those individuals who are successful (fittest) then mate to create more offspring than others
		\item Genes from “fittest” parent propagate throughout the generation, that is sometimes parents create offspring which is better than either parent, thus each successive generation is more suited for their environment.
		\item Repeat from step 2 until the condition to stop the algorithm are met (limit of generations reached, best solution reached(if known), extinction, endless evolution, etc..)   
	\end{enumerate}
	If we want to be more specific in the explaining of a GA, we need to clarify how each step work: 
	\begin{enumerate}
		\item Step 1: 
		\newline
		\begin{itemize}
			\item To define an initial population, random string is generated (the specific type of those strings does not matter when designing the algorithm, only when you need to implement the operators)
			\item the number of generated string is set during the design phase
			\item the number of individuals is constant during each iteration( generation) of the program, that means that the number of offspring individuals generated is similar to the number of the individuals that didn't survive
			\item if the knowledge on the domain is enough, you can avoid the random generation and using a custom set of individuals.
		\end{itemize}
		
		\item Step 2: \newline
		\begin{itemize}
			\item you define a function that determines which individual is fit to survive the next generation and can mate with other individuals. This function takes the name of \textbf{fitness}. This function is applied to every individual on each generation and returns a value in the range of [0,1] for each individual, and this value represents the probability to survive and create an offspring in the next generation.
			\item you define another function, called \textbf{objective}, which determines where there is an individual that fits the criteria in the best way possible, and that is marked as a correct solution for the GA, therefore stopping it, if necessary.
		\end{itemize}
		\item Step 3:
		\begin{itemize}
			\item During the selection process, a group of individuals that passed the fitness function are grouped inside a \textbf{mating pool}, where they are chosen in random pairs, for the reproduction part of the GA. There are several different reproduction methods, more or less plausible biologically. We are going to describe the most common selection algorithms:
			\begin{enumerate}
				\item  proportional selection to fitness \textbf{(FPS)} : is the most common method used for selection : we denote with $f_i$ the fitness associated to the i-Th element
				selected for reproduction with the chance of:
				\[p_i= \frac{f_i}{\sum_{j}^{} } \]
				This method is by far the most plausible biologically speaking,  but it has some problems :
				\begin{itemize}
					\item \textbf{Premature convergence}: if an item has a fitness much greater then the average, it will be always selected
					\item \textbf{Stagnation}: after some generations are passed, all elements will be electable for the selection, so no one gets discriminated against.
					\item \textbf{Slow execution}: Since the algorithm has to calculate the fitness of every item each generation, the result will be a slow execution of the program itself.
				\end{itemize}
				\item \textbf{elite selection}: The elite selection method requires that at least one copy of the best individual is preserved through a generation. This speeds up the execution of the selection using its fast convergence to find a solution, but, if the fittest item has some dominant characters, it will be always chosen and you can get caught up in local highs. 
				\item \textbf{Ranked selection}: this method provides for the organization of individuals is based on fitness, so that $ f_i \geq f_j $ for $i<j$
				\subitem A decreasing probability is assigned as a function of the position in ranking, regardless of the value of fitness, and The worst individuals are heavily penalized (or even discarded). This solves the problems regarding the elite selection, but, such a method, is not biological in the slightest and is very heavy on the computational side of the algorithm
				\item \textbf{Tournament selection}: The tournament selection method involves the creation of a group of N (N $>$ 2) individuals chosen at random: the ones with the most fitness gets chosen and can reproduce. This method is similar to the rank selection, but it doesn't need any kind of ordering between the items.
			\end{enumerate}
			\item After the selection method, the resulting items inside the mating pool get paired and a mating algorithm is applied to them.            
		\end{itemize}
	\end{enumerate}
	
	Now we are going to talk about these concepts and ideas using python.
	
	
	
	
	\subsection{How the research was carried out}
	The information on this research are obtained from different sources, such as Wikipedia (for the first chapter), and the documentation for these libraries available on GitHub, PyPI, and their respective libraries sites. 
	
	\section{Deap}
	\subsection{Description of the library}
	Developed by François-Michel De Rainville, Félix-Antoine Fortin, Marc-André Gardner, Marc Parizeau, Christian Gagné at Université Laval 
	DEAP is a novel evolutionary computation framework for rapid prototyping and testing of ideas. It seeks to make algorithms explicit and data structures transparent. It works in perfect harmony with parallelization mechanisms such as multiprocessing and SCOOP (Scalable Concurrent Operations in Python, allowing parallel programming on various environments).
	\subsection{License of use}
	DEAP is licensed under the
	GNU Lesser General Public License v3.0
	\subsection{Features}
	\begin{itemize}
		\item Genetic algorithm using any imaginable representation
		\item Genetic programming using prefix trees
		\subitem Loosely typed, Strongly typed
		\subitem Automatically defined functions
		\item Evolution strategies (including CMA-ES)
		\item Multi-objective optimization (NSGA-II, NSGA-III, SPEA2, MO-CMA-ES)
		\item Co-evolution (cooperative and competitive) of multiple populations
		\item Parallelization of the evaluations (and more)
		Hall of Fame of the best individuals that lived in the population
		\item Checkpoints that take snapshots of a system regularly
		\item Benchmarks module containing most common test functions
		\item Genealogy of evolution (that is compatible with NetworkX)
		\item Examples of alternative algorithms: Particle Swarm Optimization, Differential Evolution, Estimation of Distribution Algorithm
	\end{itemize}
	\subsection{Python compatibility (2.x and 3.x)}
	The most basic features of DEAP requires Python2.6. To combine the toolbox and the multiprocessing module Python2.7 is needed for its support to pickle partial functions. 
	Since version 0.8, DEAP is compatible out of the box with Python 3. The installation procedure automatically translates the source to Python 3 with 2to3.
	\subsection{Dependencies}
	\begin{itemize}
		\item CMA-ES requires Numpy
		\item matplotlib for visualization of results as it is fully compatible with DEAP's API.
	\end{itemize}
	\subsection{Genetic operators available}
	DEAP provides a plethora of genetic operators for each phase of the algorithm (initialization, selection, cross-over, mutation, and even migration between 2 populations). For a complete list of the operators you can find it \href{https://deap.readthedocs.io/en/master/api/tools.html}{here}.
	\subsection{How genotypes are represented}
	DEAP does not come with generic representations of genotypes, because there is an extremely large variety of individuals that can be represented, making it impossible to create all types, but instead you can create custom individuals using their functions. Here's a simple list:
	\begin{itemize}
		\item List of floats
		\item Permutations
		\item Prefix tree of mathematical expressions
		\item Evolution strategies( 2 arrays: 1 for the population, 1 for the possible mutations)
		\item Custom one created by the user.
	\end{itemize}
	\subsection{exploitation of parallelism}
	DEAP implements and exploit the concept of parallelism using :
	\begin{itemize}
		\item   \textit{Scalable Concurrent Operations in Python} \textbf{(SCOOP)},a distributed task module allowing concurrent parallel programming on various environments.
		\item Multiprocessing Module available in python
	\end{itemize}
	\subsection{Guides and tutorials}
	DEAP provides a detailed documentation concerning the use of the library, as well  a section concerning the benchmark algorithms
	\subsection{learning curve in using the library}
	DEAP is quite a straightforward and easy to understand library, thanks to the documentation provided by the authors, but it requires a good knowledge of the python language to begin with since it requires to create a custom population and fitness functions most of the times.
	\subsection{Conda environment}
	An Anaconda environment will be provided named \textit{DEAP-CONDA}, using python 3.7.4 ( the latest version since the project was created), implementing the knapsack algorithm found on the docs.
	\subsection{Publications}
	\begin{itemize}
		\item 
		François-Michel De Rainville, Félix-Antoine Fortin, Marc-André Gardner, Marc Parizeau and Christian Gagné, "DEAP -- Enabling Nimbler Evolutions", SIGEVOlution, vol. 6, no 2, pp. 17-26, February 2014. \href{http://vision.gel.ulaval.ca/~cgagne/pubs/sigevolution2014.pdf}{Link}
		\item  Félix-Antoine Fortin, François-Michel De Rainville, Marc-André Gardner, Marc Parizeau and Christian Gagné, "DEAP: Evolutionary Algorithms Made Easy", Journal of Machine Learning Research, vol. 13, pp. 2171-2175, jul 2012. \href{http://jmlr.csail.mit.edu/papers/v13/fortin12a.html}{Link}
		\item  François-Michel De Rainville, Félix-Antoine Fortin, Marc-André Gardner, Marc Parizeau and Christian Gagné, "DEAP: A Python Framework for Evolutionary Algorithms", in !EvoSoft Workshop, Companion proc. of the Genetic and Evolutionary Computation Conference (GECCO 2012), July 07-11 2012. \href{http://vision.gel.ulaval.ca/~cgagne/pubs/deap-gecco-2012.pdf}{Link}
		
	\end{itemize}
	\subsection{Projects using this library}
	\begin{itemize}
		\item 
		Ribaric, T., & Houghten, S. (2017, June). Genetic programming for improved cryptanalysis of elliptic curve cryptosystems. In 2017 IEEE Congress on Evolutionary Computation (CEC) (pp. 419-426). IEEE.
		\item Ellefsen, Kai Olav, Herman Augusto Lepikson, and Jan C. Albiez. "Multiobjective coverage path planning: Enabling automated inspection of complex, real-world structures." Applied Soft Computing 61 (2017): 264-282.
		\item S. Chardon, B. Brangeon, E. Bozonnet, C. Inard (2016), Construction cost and energy performance of single family houses : From integrated design to automated optimization, Automation in Construction, Volume 70, p.1-13.
		\item B. Brangeon, E. Bozonnet, C. Inard (2016), Integrated refurbishment of collective housing and optimization process with real products databases, Building Simulation Optimization, pp. 531–538 Newcastle, England.
		\item Randal S. Olson, Ryan J. Urbanowicz, Peter C. Andrews, Nicole A. Lavender, La Creis Kidd, and Jason H. Moore (2016). Automating biomedical data science through tree-based pipeline optimization. Applications of Evolutionary Computation, pages 123-137.
		\item Randal S. Olson, Nathan Bartley, Ryan J. Urbanowicz, and Jason H. Moore (2016). Evaluation of a Tree-based Pipeline Optimization Tool for Automating Data Science. Proceedings of GECCO 2016, pages 485-492.
		\item Van Geit W, Gevaert M, Chindemi G, Rössert C, Courcol J, Muller EB, Schürmann F, Segev I and Markram H (2016). BluePyOpt: Leveraging open source software and cloud infrastructure to optimise model parameters in neuroscience. Front. Neuroinform. 10:17. 
		\item  Lara-Cabrera, R., Cotta, C. and Fernández-Leiva, A.J. (2014). Geometrical vs topological measures for the evolution of aesthetic maps in a rts game, Entertainment Computing,
		\item Macret, M. and Pasquier, P. (2013). Automatic Tuning of the OP-1 Synthesizer Using a Multi-objective Genetic Algorithm. In Proceedings of the 10th Sound and Music Computing Conference (SMC). (pp 614-621).
		\item  Fortin, F. A., Grenier, S., & Parizeau, M. (2013, July). Generalizing the improved run-time complexity algorithm for non-dominated sorting. In Proceeding of the fifteenth annual conference on Genetic and evolutionary computation conference (pp. 615-622). ACM.
		\item  Fortin, F. A., & Parizeau, M. (2013, July). Revisiting the NSGA-II crowding-distance computation. In Proceeding of the fifteenth annual conference on Genetic and evolutionary computation conference (pp. 623-630). ACM.
		\item  Marc-André Gardner, Christian Gagné, and Marc Parizeau. Estimation of Distribution Algorithm based on Hidden Markov Models for Combinatorial Optimization. in Comp. Proc. Genetic and Evolutionary Computation Conference (GECCO 2013), July 2013.
		\item  J. T. Zhai, M. A. Bamakhrama, and T. Stefanov. "Exploiting Just-enough Parallelism when Mapping Streaming Applications in Hard Real-time Systems". Design Automation Conference (DAC 2013), 2013.
		\item  V. Akbarzadeh, C. Gagné, M. Parizeau, M. Argany, M. A Mostafavi, "Probabilistic Sensing Model for Sensor Placement Optimization Based on Line-of-Sight Coverage", Accepted in IEEE Transactions on Instrumentation and Measurement, 2012.
		\item   M. Reif, F. Shafait, and A. Dengel. "Dataset Generation for Meta-Learning". Proceedings of the German Conference on Artificial Intelligence (KI'12). 2012.
		\item  M. T. Ribeiro, A. Lacerda, A. Veloso, and N. Ziviani. "Pareto-Efficient Hybridization for Multi-Objective Recommender Systems". Proceedings of the Conference on Recommanders Systems (!RecSys'12). 2012.
		\item   M. Pérez-Ortiz, A. Arauzo-Azofra, C. Hervás-Martínez, L. García-Hernández and L. Salas-Morera. "A system learning user preferences for multiobjective optimization of facility layouts". Pr,oceedings on the Int. Conference on Soft Computing Models in Industrial and Environmental Applications (SOCO'12). 2012.
		\item    Lévesque, J.C., Durand, A., Gagné, C., and Sabourin, R., Multi-Objective Evolutionary Optimization for Generating Ensembles of Classifiers in the ROC Space, Genetic and Evolutionary Computation Conference (GECCO 2012), 2012.
		\item    Marc-André Gardner, Christian Gagné, and Marc Parizeau, "Bloat Control in Genetic Programming with Histogram-based Accept-Reject Method", in Proc. Genetic and Evolutionary Computation Conference (GECCO 2011), 2011.
		\item  Vahab Akbarzadeh, Albert Ko, Christian Gagné, and Marc Parizeau, "Topography-Aware Sensor Deployment Optimization with CMA-ES", in Proc. of Parallel Problem Solving from Nature (PPSN 2010), Springer, 2010.
		\item   DEAP is used in TPOT, an open source tool that uses genetic programming to optimize machine learning pipelines.
		\item   DEAP is also used in ROS as an optimization package.
		\item     DEAP is an optional dependency for PyXRD, a Python implementation of the matrix algorithm developed for the X-ray diffraction analysis of disordered lamellar structures.
		\item  DEAP is used in glyph, a library for symbolic regression with applications to MLC.
		
	\end{itemize}
	\subsection{Sources}
	All information regarding this library comes from:
	\begin{itemize}
		\item \href{https://github.com/deap/deap}{GitHub}
		\item \href{https://deap.readthedocs.io/en/master/}{Read the docs.io}
	\end{itemize}
	
	\section{Pyvolution}
	
	\subsection{Description of the library}
	Evolutionary Algorithms Framework, written purely in python 2.7, developed by Ashwin Panchapakesan.
	\subsection{License of use}
	Pyvolution runs under the Apache License, Version 2.0.
	\subsection{Features}
	This library features the most basic functions that are required to implement a GA. In the next paragraphs, there will be a more detailed explanation of all of the features available. 
	\subsection{Python compatibility (2.x and 3.x)}
	Pyvolution requires python 2.7 and will not work with python 2.6. It can easily be transformed into python 2.6 compliant code. Most of the incompatibilities come from list/dict comprehension expressions, however, it is not compatible with python 3.x
	\subsection{Dependencies}
	The requirements for this library are:
	\begin{itemize}
		\item PyGame (and all its dependencies)
		\subitem Used in visualization of the included TSP solver
		\item pycontract (contract)
		\subitem Used for contract checking (only when testmode is True)
	\end{itemize}
	\subsection{Genetic operators available}
	The only genetic operators available on this library, by default, are :
	\begin{itemize}
		\item Tournament Select
		\item Roulette Wheel Select
		\subitem if you are using the Roulette wheel, you have access into another function that returns a list of 3-tuples  (Individual, lowerBound, UpperBound) for each individual
		\item crossover and mutation are not implemented since they change based on the GA
	\end{itemize}
	\subsection{How genotypes are represented}
	\begin{itemize}
		\item The genotypes are represented using a class.  The original implementation treats each chromosome differently. Therefore, all the chromosomes of an individual are maintained in a list as opposed to a set.
		\item Also there are implemented methods to the individual class that help identify an individual, define its hash, test its equality to another individual instance, etc
		\item the population is implemented using two functions:
		\subitem chromGenfuncs: a list of functions. This function is based on the idea here is that each individual in the population is made up of C chromosomes. These C chromosomes are generated independently of each other for each individual in the initial population. Therefore, there must be exactly C functions listed in chromGenfuncs. The i-th function in chromGenfuncs will be used to generate the i-th chromosome of each individual
		\subitem chromGenParams: a list of tuples. There should be exactly as many tuples in this list, as there are functions in chromGenfuncs. 
	\end{itemize}
	\subsection{exploitation of parallelism}
	Pyvolution has no internal method to exploit parallelism, however, since it is compatible with Python 2.7+, it can use SCOOP to work in parallel. 
	\subsection{Guides and tutorials}
	The official docs of Pyvolution show only an example of genetic algorithm, the TSP (traveling salesman problem ), the name comes from its most typical representation: given a set of cities, and known the distances between each pair of them, find the minimum distance journey that a salesman must follow to visit all the cities once and only once. When writing this document, the official documentation does not contain other tutorials.
	\subsection{learning curve in using the library}
	Since this library is poorly documented, its use will be difficult for anyone not familiar with the python language, and for anyone looking to implement any algorithm using this library. However, that does not take away from the fact of its stability and practicality of the founding ideals, which this library is based on
	\subsection{Conda environment}
	The Conda environment created to test this library is named \textit{CONDA-PYVOLUTION} and implements the TSP.
	\subsection{Publications}
	\begin{itemize}
		\item Hydrodynamic modelling of coastal inundation \href{https://www.researchgate.net/publication/264042269_Hydrodynamic_modelling_of_coastal_inundation}{Link}
		\item The Python-OpenDSS co-simulation for the evolutionary multiobjective optimal allocation of the single tuned passive power filters \href{https://ieeexplore.ieee.org/abstract/document/8188697}{Link}
		\item Investigating the effectiveness and optimal spatial arrangement of low-impact development facilities \href{https://www.sciencedirect.com/science/article/pii/S0022169419307280}{Link}
	\end{itemize}
	\subsection{Projects using this library}
	\begin{itemize}
		\item Hydrodynamic modelling of coastal inundation
		\item Investigating the effectiveness and optimal spatial         arrangement of low-impact development facilities
	\end{itemize}
	\subsection{Sources}
	\begin{itemize}
		\item \href{https://github.com/inspectorG4dget/Genetic-Framework/tree/master/pyvolution/Documentation}{GitHub}
		\item \href{https://scholar.google.com/scholar?hl=it&as_sdt=02C5&q=pyeasyga&btnG=}{Google Scholar}
	\end{itemize}
	
	\section{Pyeasyga}
	\subsection{Description of the library}
	Developed by Ayodeji Remi-Omosowon, Pyeasyga is a  simple and easy-to-use implementation of a Genetic Algorithm library in Python, that provides a simple interface to the power of Genetic Algorithms (GAs), so that you don’t have to have expert GA knowledge to use it. 
	\subsection{License of use}
	Pyeasyga is under the  BSD License (BSD)
	\subsection{Features}
	Implementation of all basic ga functionality
	\subsection{Python compatibility (2.x and 3.x)}
	Pyeasyga uses Python 3.4  without breaking Python 2 compatibility, however, in the test was used python 3.7
	\subsection{Dependencies}
	\begin{itemize}
		\item Sphinx $\rightarrow$ 1.2.2
		\item sphinx-rtd-theme $\rightarrow$ 0.1.6
		\item coverage $\rightarrow$ 3.7.1
		\item flake8 $\rightarrow$ 2.2.0
		\item tox $\rightarrow$ 1.7.1
		\item wheel $\rightarrow$ 0.23.0
		\item six $\rightarrow$ 1.9.0
	\end{itemize}
	\subsection{Genetic operators available}
	\begin{itemize}
		\item crossover
		\item mutation
		\item random selection
		\item tournament selection
		\item rank population
		\item elitism
		\item best individual
	\end{itemize}
	\subsection{How genotypes are represented}
	Pyeasyga documentation does not directly tell you how you can represent the genotypes, however,  the examples provided they use lists, matrix, sets to work with, whereby, as long you can tweak the default functions provided by this library, you can represent the genotypes any way you want.
	\subsection{exploitation of parallelism}
	pyvolution has no internal method to exploit parallelism, however, since it is compatible with Python 2.7+, it can use SCOOP to work in parallel.
	\subsection{Guides and tutorials}
	Pyeasyga provides some practical examples of how to use this library, instead of giving you the specification of all the features it provides. 
	\subsection{learning curve in using the library}
	Overall, the setup and basic testing of this library was rather easy, because it is created with the idea of giving a more practical approach into the world of gas, instead of giving a theoretical one. It is recommended for anyone entering the world of genetic algorithms, even without much knowledge of the domain.
	\subsection{Publications}
	\begin{itemize}
		\item Applying computational intelligence to a real-world container loading problem in a warehouse environment \href{http://irep.ntu.ac.uk/id/eprint/33547/}{Link}
		\item Considerations on using genetic algorithms for the 2D bin packing problem: A general model and detected difficulties \href{https://ieeexplore.ieee.org/abstract/document/8107051}{Link}
		\item {SOPHIA}: Online Reconfiguration of Clustered NoSQL Databases for Time-Varying Workloads \href{https://www.usenix.org/conference/atc19/presentation/mahgoub}{Link}
	\end{itemize}
	\subsection{Projects using this library}
	\begin{itemize}
		\item Applying computational intelligence to a real-world container loading problem in a warehouse environment
		\item Considerations on using genetic algorithms for the 2D bin packing problem: A general model and detected difficulties
		\item {SOPHIA}: Online Reconfiguration of Clustered NoSQL Databases for Time-Varying Workloads
	\end{itemize}
	\subsection{Conda environment}
	The environment created for the user of this library is called \textit{CONDA-EASY} and implements the 1-dimensional knapsack algorithm
	\subsection{Source of origin}
	\begin{itemize}
		\item \href{https://github.com/remiomosowon/pyeasyga}{GitHub}
		\item \href{https://pyeasyga.readthedocs.io/en/latest/readme.html}{Read the docs}
		\item \href{https://scholar.google.com/scholar?hl=it&as_sdt=02C5&q=pyeasyga&btnG=}{Google Scholar}
		
	\end{itemize}
	
	\section{Inspyred}
	\subsection{Description of the library}
	Developed by Aaron Garrett, the inspyred library grew out of insights from Ken de Jong’s book “Evolutionary Computation: A Unified Approach.” The goal of the library is to separate problem-specific computation from algorithm-specific computation.
	\subsection{License of use}
	Inspyred is distributed under the MIT License. 
	\subsection{Features}
	\begin{itemize}
		\item Evolutionary Computation
		\subitem ec – Evolutionary computation framework
		\subitem emo – Evolutionary multiobjective optimization
		\subitem analysis – Optimization result analysis
		\subitem utilities – Optimization utility functions
		\item Operators
		\subitem archivers – Solution archival methods
		\subitem  evaluators – Fitness evaluation methods
		\subitem generators – Solution generation methods
		\subitem migrators – Solution migration methods
		\subitem observers – Algorithm monitoring methods
		\subitem replacers – Survivor replacement methods
		\subitem selectors – Parent selection methods
		\subitem terminators – Algorithm termination methods
		\subitem variators – Solution variation methods
		\item Swarm Intelligence
		\subitem swarm – Swarm intelligence
		\subitem topologies – Swarm topologies
		\item Benchmark Problems
		\subitem benchmarks – Benchmark optimization functions
		\subitem Single-Objective Benchmarks
		\subitem Multi-Objective Benchmarks
		\subitem Discrete Optimization Benchmarks
		
	\end{itemize}
	\subsection{Python compatibility (2.x and 3.x)}
	Requires at least Python 2.6+ or 3+.
	\subsection{Dependencies}
	\begin{itemize}
		\item Numpy and Pylab are required for several functions in the observers for the evolutionary computation framework.
		\item Pylab and Matplotlib are required for several functions in the analysis of the evolutionary computation framework.
		\item Parallel Python (pp) is required if you need to work in parallel
	\end{itemize}
	\subsection{Genetic operators available}
	\begin{itemize}
		\item  Selection
		\subitem default  (all individuals)
		\subitem truncation (only the best individuals)
		\subitem uniform (random individuals)
		\subitem fitness proportionate
		\subitem rank
		\subitem tournament
		\item re-placer 
		\subitem default  (no replacement)
		\subitem truncation (the entire population become the individual, between population and offspring,  keeping the existing population size fixed)
		\subitem steady-state replacement ( the offspring replace the least fit individuals in the existing
		population, even if those offspring are less fit than the individuals
		that they replace.)
		\subitem generational (Performs generational replacement with optional weak elitism)
		\subitem random ( random replacement with optional weak elitism)
		\subitem plus (the entire existing population is replaced by the best population-many elements from the combined set of parents and offspring)
		\subitem comma ( the entire existing population is replaced by the best population-many elements from the offspring. This function assumes that the size of the offspring is at least as large as the original population. Otherwise, the    population size will not be constant)
		\subitem crowding (  the members of the population are replaced one-at-a-time with each of the offspring, based on the distance between a random sample of the population, and the closest individual to the current offspring, if the offspring is better)
		\subitem simulated annealing schedule replacement
		\subitem NGSA-II sorting
		\subitem  Pareto Archived Evolution Strategy replacement
		\item Cross-over
		\subitem custom
		\subitem n-point
		\subitem uniform (coin flip to choose if the offspring gets the "mom" or "dad" element, with optional bias)
		\subitem partially matched (cross-over more likely to happen if the individual are from the same generation)
		\subitem arithmetic (is similar to a generalized weighted averaging of the candidate elements, with the option of shifting the weight)
		\subitem blend (similar to arithmetic, with a bit of mutation)
		\subitem heuristic (similar to the update rule used in particle swarm optimization)
		\subitem simulated binary (following the implementation in NSGA-II )
		\subitem Laplace ( following the implementation specified in (Deep and Thakur, "A new crossover operator for real coded genetic algorithms," Applied Mathematics and Computation, Volume 188, Issue 1, May 2007, pp. 895--911))
		\item Variation
		\subitem default (no variation)
		\item Mutation 
		\subitem Custom
		\subitem Bit flip
		\subitem random reset (if the solutions are composed o discrete values)
		\subitem scramble
		\subitem inversion
		\subitem gaussian
		\subitem non-uniform (performs nonuniform mutation as specified in (Michalewicz, "Genetic Algorithms
		+ Data Structures = Evolution Programs," Springer, 1996))
		
	\end{itemize}
	\subsection{How genotypes are represented}
	Inspyred re-present individuals as an object, which is given to a function that generates the population, since all choices of which individual should survive is based on the fitness function. 
	However, giving the nature of the possible combination of values that an individual can represent, you cannot apply every cross-over/mutation algorithm, because of the nature of values that these operators work with.
	\subsection{exploitation of parallelism}
	Inspyred fully support parallelism when use the parallel python (\textit{pp}) library
	\subsection{Guides and tutorials}
	The documentation provides a list of the most common examples, such as : 
	\begin{itemize}
		\item Schwefel benchmark (GA);
		\item Rosenbrock benchmark (ES);
		\item  Sphere benchmark (SA) ;
		\item Griewank benchmark (DEA);
		\item Rastrigin benchmark (EDA);
		\item Kursawe multiobjective benchmark (PAES);
		\item Kursawe multiobjective benchmark (NGSA-II);
		\item Ackley benchmark (PSO);
		\item TSP benchmark (ACS);
		\item knapsack problem ;
	\end{itemize}
	Each python file is documented thoroughly, specifying how each function works and how it relates to the overall algorithm, making rather easy the choice of which operator/s should be used each generation. 
	\subsection{learning curve in using the library}
	The overall usage of this library, is kinda simple, given the fact that you already are enough knowledgeable on how python work with classes and math libraries. 
	\subsection{Conda environment}
	The environment created to test this library is called "CONDA-INSP", which implements the Schwefel benchmark algorithm, solved using GA, and, an optimization on a Gravity Slingshot for a space probe designed to travel around the moon and return to earth
	\subsection{Publications}
	\begin{itemize}
		\item   Population Generation from Statistics Using Genetic Algorithms with MIST+ INSPYRED \href{https://sites.google.com/site/jacobbarhak/home/MODSIM2014_MIST_INSPYRED_Paper_Submit_2014_03_10.pdf}{Link}
	\end{itemize}
	\subsection{Projects using this library}
	\begin{itemize}
		\item    Population Generation from Statistics Using Genetic Algorithms with MIST+ INSPYRED
	\end{itemize}
	\subsection{Source of origin}
	\begin{itemize}
		\item \href{https://pythonhosted.org/inspyred/index.html}{Documentation}
		\item \href{https://scholar.google.com/scholar?hl=it&as_sdt=02C5&q=pyeasyga&btnG=}{Google Scholar}
		\item \href{https://github.com/aarongarrett/inspyred}{GitHub}
	\end{itemize}
	
	\section{GAFT}
	\subsection{Description of the library}
	Developed by Shao Zhengjiang, GAFT (\textbf{Genetic Algorithm Framework in pyThon}) is a general Python Framework for genetic algorithm computation. It provides built-in genetic operators for target optimization and plugin interfaces for users to define your genetic operators and on-the-fly analysis for algorithm testing.
	\subsection{License of use}
	GAFT is published under the GPLv3 license.
	\subsection{Features}
	\begin{itemize}
		\item MPI (Message Passage Interface, for parallelism exploitation)
		\item Initialization
		\item Selection
		\item Crossover
		\item Mutation
		\item Storing and analysis information on the fly
	\end{itemize}
	\subsection{Python compatibility (2.x and 3.x)}
	GAFT requires Python version 3.x (Python 2.x is not supported).
	\subsection{Dependencies}
	If you want to run your optimization flow in parallel for acceleration, you need to install an implementation of MPI on your machine and then mpi4py package.
	\subsection{Genetic operators available}
	\begin{itemize}
		\item MPI (Message Passage Interface, for parallelism exploitation)
		\item Initialization
		\subitem Binary individual
		\subitem Decimal encoding
		\subitem Custom
		\item Selection
		\subitem Roulette wheel 
		\subitem Tournament
		\subitem Rank
		\subitem Exponential ranking 
		\item Crossover
		\subitem Uniform 
		\item Mutation
		\subitem Flip bit
		\item Storing information on the fly
		\subitem Fitness
		\subitem Population finished
		\subitem Population during execution
		\subitem Custom
	\end{itemize}
	\subsection{How genotypes are represented}
	The genotypes are represented using a class, that, when it passed into a function, it creates an individual and then a population. The default implementations of individuals consist of binary and decimal genotypes, although, GAFT only needs an object to create an individual, so it supports custom types, but it is necessary to create every function needed by the class too.
	\subsection{exploitation of parallelism}
	GAFT uses a utility class named \textit{mpiutil}, for parallelizing the Genetic Algorithm by using MPI interfaces in a distributed MPI environment.
	\subsection{Guides and tutorials}
	The GAFT documentation it's well-stocked in describing its functioning, however, there are only two examples given to test the framework, which is a 1D global max, and one 1D optimization (global min)
	\subsection{learning curve in using the library}
	GAFT has a limited number of built-in functions, making it rather  easy to remember their uses, but, on the other hand, other than some basic functions, it requires an implementation starting from of every other common function for each phase of the GA
	\subsection{Publications}
	No publications found on google scholar and Research gate
	\subsection{Projects using this library}
	No publications found on google scholar and Research gate
	\subsection{Conda environment}
	The environment used to test the Framework is called \textit{CONDA-GAFT}, implementing the example given inside the docs. 
	\subsection{Source of origin}
	\begin{itemize}
		\item \href{https://gaft.readthedocs.io/en/latest/api/index.html}{Read the docs}
		\item \href{https://github.com/PytLab/gaft}{GitHub}
	\end{itemize}
	
	\section{Pyevolve}
	\subsection{Description of the library}
	Developed by Christian Perone, Pyevolve is an open-source framework for genetic algorithms. The initial long-term goal of the project was to create a complete and multi-platform framework for genetic algorithms in pure python.
	\subsection{License of use}
	The framework is entirely open-source and it is licensed upon a very permissive PSF2-like license.
	\subsection{Features}
	\begin{itemize}
		\item Evolutionary algorithms (genetic programming  and gas)
		\item Graphical plotting
		\item Database and visualization adapters
		\item Interaction support
		\item Basic standard features for genetic operators, scaling, selection, etc
	\end{itemize}
	\subsection{Python compatibility (2.x and 3.x)}
	the framework was written in pure Python, so it can run on Mac, Windows, Linux platforms, and on any portable devices where Python is available (e.g., the Sony PlayStation Portable Symbian OS based cellphones)
	\subsection{Dependencies}
	\begin{itemize}
		\item Biopython
		\item Scipy
		\item Numpy $\geq 1.7$
	\end{itemize}
	\subsection{Genetic operators available}
	\begin{itemize}
		\item Initialization 
		\subitem 1D binary string 
		\subitem 2D binary string
		\subitem 1D list
		\subitem 2D list
		\subitem Tree
		\subitem Custom
		\item Crossover
		\begin{itemize}
			\item  1D binary string
			\subitem single point
			\subitem 2 point
			\subitem uniform
			\item 1D list 
			\subitem single point
			\subitem 2 point
			\subitem uniform 
			\subitem order
			\item 2D list  
			\subitem single vertical point
			\subitem single horizontal point
			\subitem uniform
			\item Tree 
			\subitem sub-tree
			\subitem strict sub-tree
		\end{itemize}
		\item Mutation 
		\begin{itemize}
			\item  1D binary string
			\subitem swap
			\subitem flip
			\item 1D list 
			\subitem swap
			\subitem integer-Gaussian 
			\subitem real-Gaussian
			\subitem Custom
			\item 2D list  
			\subitem swap
			\subitem integer-Gaussian 
			\subitem real-Gaussian
			\subitem Custom
			\item Tree 
			\subitem swap
			\subitem integer-Gaussian 
			\subitem real-Gaussian
			\subitem integer-range 
			\subitem real-range
		\end{itemize}
		\item Selection 
		\subitem Linear
		\subitem Sigma truncation
		\subitem Power-law
		\subitem Boltzmann
		\subitem Raw
		\item Scaling 
		\subitem Rank
		\subitem Uniform
		\subitem Tournament
		\subitem Roulette wheel
		\item Pausing
	\end{itemize}
	\subsection{How genotypes are represented}
	The framework includes the classical representations used in genetic algorithms ( 1D and 2D Binar Strings) and several other representations ( 1D and 2D Lists, and Trees). What deﬁnes the data type of the representation is the genetic algorithm initialization function. Pyevolve provides ready-to-use built-in initialization routines for integer numbers, real numbers, and user-deﬁned alleles. Besides the few representations available in the distribution, the ﬂexibility of Python allows the creation of new representations by extending the existing ones.  
	\subsection{exploitation of parallelism}
	Pyevolve has built-in support for the usage of multiple cores, alternating the CPU cores during the fitness evaluation, for each individual in the population.
	\subsection{Guides and tutorials}
	Pyevolve documentation is very well made, explaining every single function built-in, as well as giving a great amount of examples, varying from the simple algorithms into the benchmark problems.
	\subsection{learning curve in using the library}
	This framework is one of the most documented on the market, making it one of the simplest to use, and, because of that, you can find a great amount of research papers and support during each phase of learning/using the framework, to help you master all the features it has to offer.
	\subsection{Publications}
	\begin{itemize}
		\item  Pyevolve: a Python open-source framework for genetic algorithms \href{}{Link}
		\item Effects of Optical Parameters in a Free-Electron Laser Oscillator \href{https://iopscience.iop.org/article/10.1143/JJAP.49.076401/meta}{Link}
		\item Using a Meta-GA for parametric optimization of simple gas in the computational chemistry domain \href{https://www.researchgate.net/profile/Zoe_Brain/publication/220740459_Using_a_Meta-GA_for_parametric_optimization_of_simple_gas_in_the_computational_chemistry_domain/links/54e5a6bc0cf29865c3375545/Using-a-Meta-GA-for-parametric-optimization-of-simple-gas-in-the-computational-chemistry-domain.pdf}{Link}
		\item PyEvolve: a toolkit for statistical modelling of molecular evolution \href{https://bmcbioinformatics.biomedcentral.com/articles/10.1186/1471-2105-5-1}{Link}
	\end{itemize}
	\subsection{Projects using this library}
	\begin{itemize}
		\item Effects of Optical Parameters in a Free-Electron Laser Oscillator
		\item Benchmark-guided HDF5 Application Tuning
	\end{itemize}
	\subsection{Conda environment}
	The Conda environment used to test this framework is called \textit{CONDA-PYEVOLVE}, implementing the tsp.
	\subsection{Source of origin}
	\begin{itemize}
		\item \href{https://www.researchgate.net/publication/285104816_Pyevolve_A_Python_open-source_framework_for_genetic_algorithms}{Research gate}
		\item \href{https://github.com/sjspielman/pyvolve}{Git Hub}
		\item \href{http://pyevolve.sourceforge.net/0_6rc1/index.html}{Sourceforge}
		\item \href{http://blog.christianperone.com/?s=pyevolve}{Project blog}
	\end{itemize}
	
	\section{Summary table}
	
	\section{ToDO}
	\begin{itemize}
		\item Research of papers on google docs and research gates(done)
		\item finish the summary table (after meeting)
		\item adding the publications that use these libraries/frameworks (done)
		\item syntactic and semantics check (done)
	\end{itemize}
	
\end{document}